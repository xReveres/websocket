/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <regex>
#include <sockets>
#include <base64>
#include "./websocket.inc"

#define PLUGIN "WebSocketAPI"
#define VERSION "1.0"
#define AUTHOR "Reveres"

#pragma dynamic 65536
#define EOF	0
//#define DEBUG

#define RECV_TIMERS_START	800
#define TIMEOUT_TIMERS_START	(RECV_TIMERS_START+MAX_WEBSOCKETS)

#define TIMEOUT_WAIT_TIME	5.0

enum _:WS_Opcode{
	CONTINUOUS = 0,
	TEXT = 1,
	BINARY = 2,
	CLOSE = 8,
	PING = 9,
	PONG = 10
};
// 3-7 are not yet defined
// 11-15 are not yet defined

enum _:WS_Struct{
	bool:Used,
	Plugin,
	Socket,
	Host[64],
	Port,
	Path[64],
	PSendsCount,
	PReceivedCount,
	BSends,
	BReceived,
	State,
	bool:WaitingForClose,
	//binds
	fOnOpen,
	fOnReceiveText,
	fOnReceiveBinary,
	fOnClose,
	fOnPong,
	fOnError
};

enum _:WS_FrameStruct{
	FIN,
	RSV1,
	RSV2,
	RSV3,
	OPCODE,
	MASK,
	PAYLOAD_LEN,
	MASKINGKEY[4],
	PAYLOAD[MAX_BUFFER_SIZE],
	CLOSE_REASON
};

new gWS[MAX_WEBSOCKETS][WS_Struct];

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR);
}

public plugin_end()
{
	for(new WSIndex=0; WSIndex < MAX_WEBSOCKETS; WSIndex++)
	{
		if(!gWS[WSIndex][Used])
			continue;
		closeConnection(WSIndex, WS_CLOSE_REASON_GOING_AWAY, "");
	}
}

public plugin_natives()
{
	register_library("websocket");
	
	register_native("ws_create", "WS_Create");
	register_native("ws_destroy", "WS_Destroy");
	register_native("ws_open", "WS_Open");
	register_native("ws_reconnect", "WS_Reconnect", 1);
	register_native("ws_send", "WS_Send");
	register_native("ws_close", "WS_Close");
	register_native("ws_state", "WS_State", 1);
	register_native("ws_bind", "WS_RegisterBind");
	register_native("ws_ping", "WS_Ping", 1);
}

public WS_RegisterBind(iPlugin, iParams)
{
	new WSIndex = get_param(1);
	new bind_type = get_param(2);
	new fname[32];
	get_string(3, fname, 31);
	
	if(!gWS[WSIndex][Used])
		return 0;
	switch(bind_type)
	{
		case WS_BIND_OPEN:
		{
			gWS[WSIndex][fOnOpen] = CreateOneForward(gWS[WSIndex][Plugin], fname);
		}
		case WS_BIND_RECEIVE_TEXT:
		{
			gWS[WSIndex][fOnReceiveText] = CreateOneForward(gWS[WSIndex][Plugin], fname, FP_STRING);
		}
		case WS_BIND_RECEIVE_BINARY:
		{
			gWS[WSIndex][fOnReceiveBinary] = CreateOneForward(gWS[WSIndex][Plugin], fname, FP_ARRAY, FP_CELL);
		}
		case WS_BIND_CLOSE:
		{
			gWS[WSIndex][fOnClose] = CreateOneForward(gWS[WSIndex][Plugin], fname, FP_CELL, FP_STRING);
		}
		case WS_BIND_PONG:
		{
			gWS[WSIndex][fOnPong] = CreateOneForward(gWS[WSIndex][Plugin], fname);
		}
		case WS_BIND_ERROR:
		{
			gWS[WSIndex][fOnError] = CreateOneForward(gWS[WSIndex][Plugin], fname, FP_CELL);
		}
	}
	return 1;
}

public WS_Create(iPlugin, iParams)
{
	new WSIndex = get_free_handle();
	
	if(WSIndex == -1)
		return -1;
	
	gWS[WSIndex][Used] = true;
	gWS[WSIndex][Plugin] = iPlugin;
	gWS[WSIndex][State] = WS_STATE_CLOSED;
	clearForwards(WSIndex);
	
	return WSIndex;
}

public WS_Destroy(iPlugin, iParams)
{
	new WSIndex = get_param(1);
	
	if(!gWS[WSIndex][Used])
		return -1;
	if(gWS[WSIndex][State] != WS_STATE_CLOSED)
	{
		#if defined DEBUG
		server_print("[WS.%d] Connection must be CLOSED before destroying. See ws_close");
		#endif
		return 0;
	}
	gWS[WSIndex][Used] = false;
	gWS[WSIndex][Host][0] = EOF;
	gWS[WSIndex][Path][0] = EOF;
	gWS[WSIndex][Port] = 0;
	if(gWS[WSIndex][fOnOpen] != -1)
		DestroyForward(gWS[WSIndex][fOnOpen]);
	if(gWS[WSIndex][fOnReceiveBinary] != -1)
		DestroyForward(gWS[WSIndex][fOnReceiveBinary]);
	if(gWS[WSIndex][fOnReceiveText] != -1)
		DestroyForward(gWS[WSIndex][fOnReceiveText]);
	if(gWS[WSIndex][fOnClose] != -1)
		DestroyForward(gWS[WSIndex][fOnClose]);
	if(gWS[WSIndex][fOnPong] != -1)
		DestroyForward(gWS[WSIndex][fOnPong]);
	if(gWS[WSIndex][fOnError] != -1)
		DestroyForward(gWS[WSIndex][fOnError]);
	clearForwards(WSIndex);
	return 1;
}

//public WS_Open(WSIndex, const host[], port, const path[])
public WS_Open(iPlugin, iParams)
{
	new WSIndex = get_param(1);
	
	if(!gWS[WSIndex][Used])
		return -1;
	if(gWS[WSIndex][State] != WS_STATE_CLOSED)
		return -2;
	
	get_string(2, gWS[WSIndex][Host], 63);
	gWS[WSIndex][Port] = get_param(3);
	get_string(4, gWS[WSIndex][Path], 63);
	
	return WS_Reconnect(WSIndex);
}

public WS_Reconnect(const WSIndex)
{
	if(!gWS[WSIndex][Used])
		return -1;
	if(gWS[WSIndex][State] != WS_STATE_CLOSED)
		return -2;
	
	gWS[WSIndex][PSendsCount] = 0;
	gWS[WSIndex][PReceivedCount] = 0;
	gWS[WSIndex][BSends] = 0;
	gWS[WSIndex][BReceived] = 0;
	gWS[WSIndex][State] = WS_STATE_CONNECTING;
	
	#if defined DEBUG
	server_print("[WS.%d] Trying connect to ws://%s:%d%s", WSIndex, gWS[WSIndex][Host], gWS[WSIndex][Port], gWS[WSIndex][Path]);
	#endif
	
	new error;
	gWS[WSIndex][Socket] = socket_open(gWS[WSIndex][Host], gWS[WSIndex][Port], SOCKET_TCP, error);
	
	if(error != 0)
	{
		CBsocketError(WSIndex, WS_CLOSE_REASON_ABNORMAL); //Error 1006 ?
		//gWS[WSIndex][State] = WS_STATE_CLOSED;//_WS_State:CLOSED
		return error;
	}
	
	set_task(0.01, "_rcvTask", RECV_TIMERS_START+WSIndex);
	WSHandshake(WSIndex);
	
	return 0;
}

public WSHandshake(const WSIndex)
{
	new hsh[512];
	
	new rbytes[5];
	for(new i=0; i < 5; i++)
		rbytes[i] = random(256);
	new key[128];
	Encode64(rbytes, key, charsmax(key));
	
	formatex(hsh, charsmax(hsh),
		"GET ws://%s:%d%s HTTP/1.1^r^nHost: %s^r^nUpgrade: websocket^r^nConnection: Upgrade^r^nSec-WebSocket-Key: %s^r^nSec-WebSocket-Version: 13^r^nOrigin: null^r^n^r^n",
		gWS[WSIndex][Host], gWS[WSIndex][Port], gWS[WSIndex][Path],
		gWS[WSIndex][Host],
		key);
	
	#if defined DEBUG
	server_print("[WS.%d] Handshaking server", WSIndex);
	#endif
	socket_send(gWS[WSIndex][Socket], hsh, charsmax(hsh));
}

public WS_Ping(const WSIndex)
{
	if(!gWS[WSIndex][Used])
		return -1;
	if(gWS[WSIndex][State] != WS_STATE_CLOSED)
		return -2;
	
	new sFrame[WS_FrameStruct];
	sFrame[FIN] = 1;
	sFrame[RSV1] = 0;
	sFrame[RSV2] = 0;
	sFrame[RSV3] = 0;
	sFrame[OPCODE] = _WS_Opcode:PING;
	sFrame[MASK] = 0;
	WS_SendRaw(WSIndex, sFrame);
	return 0;
}

/*
 *	WS_Send(handle, WS_DataType, useMask, data[], len=0);
 *	
 *	useMask unused
 *	Optional len when WS_DataType is Text
*/
//public WS_Send(const WSIndex, WS_DataType:type, bool:useMask, const data[], len)
public WS_Send(iPlugin, iParams)
{
	new WSIndex = get_param(1);
	new type = get_param(2);
	new useMask = get_param(3);
	new len = get_param(5);
	new data[MAX_BUFFER_SIZE];
	get_string(4, data, MAX_BUFFER_SIZE - 1);
	
	if(!gWS[WSIndex][Used])
		return -1;
	if(gWS[WSIndex][State] != WS_STATE_OPEN)
		return -2;
	
	new payloadLen = 0;
	new sFrame[WS_FrameStruct];
	
	if(type == WS_DATA_TYPE_TEXT){
		payloadLen = strlen(data);
		sFrame[OPCODE] = _WS_Opcode:TEXT;
	}else{
		payloadLen = len;
		sFrame[OPCODE] = _WS_Opcode:BINARY;
	}
	
	sFrame[FIN] = 1;
	sFrame[RSV1] = 0;
	sFrame[RSV2] = 0;
	sFrame[RSV3] = 0;
	sFrame[MASK] = useMask ? 1 : 0;
	sFrame[PAYLOAD_LEN] = payloadLen;
	copy(sFrame[PAYLOAD], MAX_BUFFER_SIZE-1, data);
	
	WS_SendRaw(WSIndex, sFrame);
	return 1;
}

public WS_SendRaw(const WSIndex, sFrame[WS_FrameStruct])
{
	new buf[MAX_BUFFER_SIZE];
	new bufLen = createByteArrayFrame(sFrame, buf);
	
	gWS[WSIndex][BSends] += bufLen;
	gWS[WSIndex][PSendsCount] ++;
	
	socket_send2(gWS[WSIndex][Socket], buf, bufLen);
}

public WS_Close(iPlugin, iParams)
{
	new WSIndex = get_param(1);
	if(!gWS[WSIndex][Used] || gWS[WSIndex][State] == WS_STATE_CLOSED)
		return;
	new data[256];
	get_string(2, data, 255);
	new iReason = get_param(3);
	
	closeConnection(WSIndex, iReason, data);
}

closeConnection(const WSIndex, iReason, const data[])
{
	#if defined DEBUG
	server_print("[WS.%d] Closing connection. Reason[%d]: %s", WSIndex, iReason, data);
	#endif
		
	if(gWS[WSIndex][State] != WS_STATE_OPEN && gWS[WSIndex][State] != WS_STATE_CLOSED)
	{
		CBsocketClose(WSIndex, iReason, data);
		return;
	}
	
	new sFrame[WS_FrameStruct];
	sFrame[FIN] = 1;
	sFrame[RSV1] = 0;
	sFrame[RSV2] = 0;
	sFrame[RSV3] = 0;
	sFrame[OPCODE] = _WS_Opcode:CLOSE;
	sFrame[MASK] = 1;
	new reasonLen = strlen(data);
	sFrame[PAYLOAD_LEN] = reasonLen + 2;
	sFrame[CLOSE_REASON] = iReason;
	sFrame[PAYLOAD][0] = ((iReason >> 8) & 0xFF);
	sFrame[PAYLOAD][1] = ((iReason >> 0) & 0xFF);
	if(reasonLen > 0)
		arraycopy(0, reasonLen, data, 2, MAX_BUFFER_SIZE, sFrame[PAYLOAD]);
		
	WS_SendRaw(WSIndex, sFrame);
	gWS[WSIndex][State] = WS_STATE_CLOSING;//_WS_State:CLOSING
	set_task(TIMEOUT_WAIT_TIME, "_timeoutTask", TIMEOUT_TIMERS_START+WSIndex);
}

public WS_State(const WSIndex)
{
	if(!gWS[WSIndex][Used])
		return -1;
	return gWS[WSIndex][State];
}

public createByteArrayFrame(sFrame[], buff[])
{
	new offset = 0;
	
	buff[offset] = (128 * sFrame[FIN]);
	buff[offset] |= (64 * sFrame[RSV1]);
	buff[offset] |= (32 * sFrame[RSV2]);
	buff[offset] |= (16 * sFrame[RSV3]);
	buff[offset] |= (sFrame[OPCODE]);
	offset++;
	
	new sizebytes = sFrame[PAYLOAD_LEN] <= 125 ? 1 : sFrame[PAYLOAD_LEN] <= 65535 ? 2 : 8;
	switch(sizebytes)
	{
		case 1:
			buff[offset++] = (sFrame[PAYLOAD_LEN] | (sFrame[MASK] ? 128 : 0));
		case 2:
		{
			buff[offset++] = (126 | (sFrame[MASK] ? 128 : 0));
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 8) & 0xFF);
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 0) & 0xFF);
		}
		case 8:
		{
			buff[offset++] = (127 | (sFrame[MASK] ? 128 : 0));
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 56) & 0xFF);
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 48) & 0xFF);
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 40) & 0xFF);
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 32) & 0xFF);
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 24) & 0xFF);
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 16) & 0xFF);
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 8) & 0xFF);
			buff[offset++] = ((sFrame[PAYLOAD_LEN] >> 0) & 0xFF);
		}
	}
	
	if(sFrame[MASK])
	{
		for(new i=0; i < 4; i++)
			buff[offset++] = sFrame[MASKINGKEY][i] = random(256);
	}

	if(sFrame[MASK])
	{
		for(new i=0,c=sFrame[PAYLOAD_LEN]; i < c; i++)
			buff[offset++] = sFrame[PAYLOAD][i] ^ sFrame[MASKINGKEY][ i % 4 ];
	}else
	{
		arraycopy(0, sFrame[PAYLOAD_LEN], sFrame[PAYLOAD], offset, MAX_BUFFER_SIZE, buff);
		offset += sFrame[PAYLOAD_LEN];
	}
		
	return offset;
}

stock arraycopy(srcOffset, srcLength, const src[], destOffset, destLength, dest[])
{
	new o = 0;
	while(srcOffset < srcLength)
	{
		o = srcOffset + destOffset;
		if(o >= destLength)
			break;
		dest[ o ] = src[ srcOffset ];
		srcOffset++;
	}
}

parsePacket(const WSIndex, const data[], const dataLen, sFrame[WS_FrameStruct], offset = 0)
{
	sFrame[FIN] = ((data[offset] >> 7) & 0x01);
	sFrame[RSV1] = ((data[offset] >> 6) & 0x01);
	sFrame[RSV2] = ((data[offset] >> 5) & 0x01);
	sFrame[RSV3] = ((data[offset] >> 4) & 0x01);
	sFrame[OPCODE] = (data[offset] & 0x0F);
	offset++;
	
	sFrame[MASK] = ((data[offset] >> 7) & 0x01) == 1;
	sFrame[PAYLOAD_LEN] = (data[offset] & 0x7F);
	if(sFrame[PAYLOAD_LEN] <= 125)
		offset++;
	else if(sFrame[PAYLOAD_LEN] == 126){
		sFrame[PAYLOAD_LEN] = (data[offset] << 8);
		sFrame[PAYLOAD_LEN] |= (data[offset] << 0);
		offset+=2;
	}else if(sFrame[PAYLOAD_LEN] == 127){
		sFrame[PAYLOAD_LEN] = (data[offset] << 56);
		sFrame[PAYLOAD_LEN] |= (data[offset] << 48);
		sFrame[PAYLOAD_LEN] |= (data[offset] << 40);
		sFrame[PAYLOAD_LEN] |= (data[offset] << 32);
		sFrame[PAYLOAD_LEN] |= (data[offset] << 24);
		sFrame[PAYLOAD_LEN] |= (data[offset] << 16);
		sFrame[PAYLOAD_LEN] |= (data[offset] << 8);
		sFrame[PAYLOAD_LEN] |= (data[offset] << 0);
		offset+=8;
	}
	
	if(sFrame[MASK])
	{
		for(new i=0; i < 4; i++)
			sFrame[MASKINGKEY][i] = data[ offset++ ];
	}
	
	if(WS_Opcode:sFrame[OPCODE] == WS_Opcode:CLOSE) //_WS_Opcode:CLOSE
	{
		sFrame[CLOSE_REASON] = ((data[offset++] & 0xFF) << 8);
		sFrame[CLOSE_REASON] |= ((data[offset++] & 0xFF) << 0);
	}

	if(sFrame[MASK])
	{
		for(new i=0,c=sFrame[PAYLOAD_LEN]; i < c; i++)
			sFrame[PAYLOAD][i] =  data[offset++] ^ sFrame[MASKINGKEY][ i % 4 ];
	}else{
		for(new i=0,c=sFrame[PAYLOAD_LEN]; i < c; i++)
			sFrame[PAYLOAD][i] = data[offset++];
	}
	if(offset < dataLen)
		CBsocketReceive(WSIndex, data, dataLen, offset);
}

public _rcvTask(id)
{
	new WSIndex = id - RECV_TIMERS_START;
	if(!gWS[WSIndex][Used] || gWS[WSIndex][State] == WS_STATE_CLOSED)
		return;
	if(socket_change(gWS[WSIndex][Socket], 0))
	//if(socket_is_readable(gWS[WSIndex][Socket]))
	{
		new buffer[MAX_BUFFER_SIZE];
		new readedBytes = socket_recv(gWS[WSIndex][Socket], buffer, MAX_BUFFER_SIZE-1);
		if(readedBytes == 0)
		{
			gWS[WSIndex][State] = WS_STATE_CLOSED;
			CBsocketError(WSIndex, WS_CLOSE_REASON_GOING_AWAY); //Timeout
		}
		else if(readedBytes <= -1)
			CBsocketError(WSIndex, WS_CLOSE_REASON_ABNORMAL); //1005 ?
		else
			CBsocketReceive(WSIndex, buffer, readedBytes);
	}
	set_task(0.05, "_rcvTask", id);
}

public _timeoutTask(id)
{
	new WSIndex = id - TIMEOUT_TIMERS_START;
	if(gWS[WSIndex][State] == WS_STATE_CLOSING)
	{
		//CBsocketClose(WSIndex, WS_CLOSE_REASON_NORMAL, "");
		gWS[WSIndex][State] = WS_STATE_CLOSED;
		socket_close(gWS[WSIndex][Socket]);
	}
}

public CBsocketOpened(WSIndex)
{
	gWS[WSIndex][State] = WS_STATE_OPEN;
	new ierr;
	if(gWS[WSIndex][fOnOpen] != -1)
		ExecuteForward(gWS[WSIndex][fOnOpen], ierr);
}

public CBsocketError(WSIndex, code)
{
	#if defined DEBUG
	server_print("[WS.%d] Error code: %d", WSIndex, code);
	#endif
	new ierr;
	if(gWS[WSIndex][fOnError] != -1)
		ExecuteForward(gWS[WSIndex][fOnError], ierr, code);
	if(gWS[WSIndex][State] != WS_STATE_CLOSED)
		closeConnection(WSIndex, code, "");
}

public CBsocketClose(WSIndex, iReason, const reason[])
{
	new prevState = gWS[WSIndex][State];
	gWS[WSIndex][State] = WS_STATE_CLOSED;
	socket_close(gWS[WSIndex][Socket]);
	closeTimeoutTask(WSIndex);
	new ierr;
	if(prevState == WS_STATE_OPEN && gWS[WSIndex][fOnClose] != -1)
		ExecuteForward(gWS[WSIndex][fOnClose], ierr, iReason, reason);
}

CBsocketReceive(WSIndex, const data[], dataLen, offset=0)
{
	switch(gWS[WSIndex][State])
	{
		case WS_STATE_CONNECTING:
		{
			new iRet, szError[32];
			new Regex:regex_handle = regex_match(data, "HTTP\/(\d.\d) (\d{1,4})", iRet, szError, charsmax(szError));

			if(regex_handle > REGEX_NO_MATCH)
				CBsocketOpened(WSIndex);
			else
				CBsocketError(WSIndex, 1002);
		}
		case WS_STATE_OPEN, WS_STATE_CLOSING:
		{
			if(offset == 0)
			{
				gWS[WSIndex][PReceivedCount] ++;
				gWS[WSIndex][BReceived] += dataLen;
			}
			new rFrame[WS_FrameStruct]
			parsePacket(WSIndex, data, dataLen, rFrame, offset);
			new ierr;
			if(gWS[WSIndex][State] == WS_STATE_CLOSING && WS_Opcode:rFrame[OPCODE] != WS_Opcode:CLOSE)
			{
				#if defined DEBUG
				server_print("[WS.%d] Received non close packet when state is closing !", WSIndex);
				#endif
				return;
			}
			switch(rFrame[OPCODE])
			{
				case (WS_Opcode:CONTINUOUS):
				{
					server_print("[WS.%d] Received unsupported CONTINUOS opcode !", WSIndex);
				}
				case (WS_Opcode:TEXT):
				{
					if(gWS[WSIndex][fOnReceiveText] != -1)
						ExecuteForward(gWS[WSIndex][fOnReceiveText], ierr, rFrame[PAYLOAD]);
				}
				case (WS_Opcode:BINARY):
				{
					if(gWS[WSIndex][fOnReceiveBinary] != -1)
						ExecuteForward(gWS[WSIndex][fOnReceiveBinary], ierr, PrepareArray(rFrame[PAYLOAD], rFrame[PAYLOAD_LEN]), rFrame[PAYLOAD_LEN]);
				}
				case (WS_Opcode:PING):
				{
					rFrame[OPCODE] = _WS_Opcode:PONG;
					WS_SendRaw(WSIndex, rFrame);
				}
				case (WS_Opcode:PONG):
				{
					if(gWS[WSIndex][fOnPong] != -1)
						ExecuteForward(gWS[WSIndex][fOnPong], ierr);
				}
				case (WS_Opcode:CLOSE):
				{
					#if defined DEBUG
					server_print("[WS.%d] Closing frame. Reason[%d]: %s", WSIndex, rFrame[CLOSE_REASON], rFrame[PAYLOAD]);
					#endif
					if(gWS[WSIndex][State] == WS_STATE_CLOSING)
					{
						gWS[WSIndex][State] = WS_STATE_CLOSED;
						socket_close(gWS[WSIndex][Socket]);
						closeTimeoutTask(WSIndex);
						return;
					}
					new sFrame[WS_FrameStruct];
					sFrame[FIN] = 1;
					sFrame[OPCODE] = _WS_Opcode:CLOSE;
					sFrame[CLOSE_REASON] = rFrame[CLOSE_REASON];
					sFrame[MASK] = 1;
					WS_SendRaw(WSIndex, sFrame);
					CBsocketClose(WSIndex, rFrame[CLOSE_REASON], rFrame[PAYLOAD]);
				}
			}
		}
	}
}

stock closeTimeoutTask(WSIndex)
{
	new tid = TIMEOUT_TIMERS_START + WSIndex;
	if(task_exists(tid))
		remove_task(tid);
}

stock clearForwards(WSIndex)
{
	gWS[WSIndex][fOnOpen] = -1;
	gWS[WSIndex][fOnReceiveBinary] = -1;
	gWS[WSIndex][fOnReceiveText] = -1;
	gWS[WSIndex][fOnClose] = -1;
	gWS[WSIndex][fOnPong] = -1;
	gWS[WSIndex][fOnError] = -1;
}

public get_free_handle()
{
	for(new i=0; i < MAX_WEBSOCKETS; i++)
		if(!gWS[i][Used])
			return i;
	return -1;
}
